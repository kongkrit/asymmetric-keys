<!doctype html><html lang="en"><head>  <meta charset="utf-8" />  <title>Web Crypto PKI Demo</title></head><body>  <h1>Web Crypto PKI Demo</h1>  <!-- Section 1 — generate keys -->  <section aria-labelledby="sec1">    <h2 id="sec1">1) Generate keys</h2>    <button id="generateX25519">Generate X25519</button>    <button id="generateEd25519">Generate Ed25519</button>    <div id="warn-sec1" role="status" aria-live="polite"></div>    <p>      <label for="privatekeyX25519">X25519 private key</label><br>      <textarea id="privatekeyX25519" rows="3" cols="80" spellcheck="false"></textarea>      <button id="copy" data-for="privatekeyX25519">copy</button>    </p>    <p>      <label for="publickeyX25519">X25519 public key</label><br>      <textarea id="publickeyX25519" rows="3" cols="80" spellcheck="false"></textarea>      <button id="copy" data-for="publickeyX25519">copy</button>    </p>    <p>      <label for="privatekeyEd25519">Ed25519 private key</label><br>      <textarea id="privatekeyEd25519" rows="3" cols="80" spellcheck="false"></textarea>      <button id="copy" data-for="privatekeyEd25519">copy</button>    </p>    <p>      <label for="publickeyEd25519">Ed25519 public key</label><br>      <textarea id="publickeyEd25519" rows="3" cols="80" spellcheck="false"></textarea>      <button id="copy" data-for="publickeyEd25519">copy</button>    </p>  </section>  <br>  <!-- Section 2 — encrypt and sign message -->  <section aria-labelledby="sec2">    <h2 id="sec2">2) Encrypt and sign</h2>    <p>      <label for="message">Message</label><br>      <textarea id="message" rows="3" cols="80">Hello asymmetric encryption</textarea>      <button id="copy" data-for="message">copy</button>    </p>    <p>      <button id="sign">Sign with Ed25519 private key</button>      <div id="warn-sign" role="status" aria-live="polite"></div>    </p>    <p>      <label for="signature">Signature (Ed25519)</label><br>      <textarea id="signature" rows="3" cols="80" spellcheck="false" readonly></textarea>      <button id="copy" data-for="signature">copy</button>    </p>    <p>      <button id="encrypt">Encrypt with X25519 public key</button>      <div id="warn-encrypt" role="status" aria-live="polite"></div>    </p>    <p>      <label for="encrypted">Encrypted payload</label><br>      <textarea id="encrypted" rows="6" cols="80" spellcheck="false" readonly></textarea>      <button id="copy" data-for="encrypted">copy</button>    </p>  </section>  <br>  <!-- Section 3 — verify and decrypt -->  <section aria-labelledby="sec3">    <h2 id="sec3">3) Verify and decrypt</h2>    <p>      <button id="verify">Verify signature</button>      <span id="valid-message-signature" aria-live="polite"></span>      <div id="warn-verify" role="status" aria-live="polite"></div>    </p>    <p>      <label for="verified">Verified echo</label><br>      <textarea id="verified" rows="4" cols="80" spellcheck="false" readonly></textarea>      <button id="copy" data-for="verified">copy</button>    </p>    <p>      <button id="decrypt">Decrypt</button>      <div id="warn-decrypt" role="status" aria-live="polite"></div>    </p>    <p>      <label for="decrypted">Decrypted message</label><br>      <textarea id="decrypted" rows="3" cols="80" spellcheck="false" readonly></textarea>      <button id="copy" data-for="decrypted">copy</button>    </p>  </section><script>/* ===== Utilities (pure) ===== */const b64u = {  enc: (buf) => {    const b = Array.from(new Uint8Array(buf), x => String.fromCharCode(x)).join('');    return btoa(b).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');  },  dec: (str) => {    const s = str.replace(/-/g,'+').replace(/_/g,'/');    const pad = '='.repeat((4 - s.length % 4) % 4);    const bin = atob(s + pad);    const out = new Uint8Array(bin.length);    for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);    return out.buffer;  }};const txt = {  enc: (s) => new TextEncoder().encode(s),  dec: (b) => new TextDecoder().decode(b)};const jsonStringifyCompact = (o) => JSON.stringify(o);/* Feature check (short) */function requireSupport() {  const subtle = crypto?.subtle;  const ok = !!subtle;  return { ok, reason: ok ? '' : 'Web Crypto unavailable.' };}/* ===== Key generation (pure) ===== */async function genX25519() {  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);  const kp = await crypto.subtle.generateKey({name:'X25519'}, true, ['deriveBits']);  const pub = await crypto.subtle.exportKey('raw', kp.publicKey);  const prv = await crypto.subtle.exportKey('pkcs8', kp.privateKey); // private export as PKCS8  return {    publicKeyB64u: b64u.enc(pub),    privateKeyB64u: b64u.enc(prv)  };}async function genEd25519() {  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);  const kp = await crypto.subtle.generateKey({name:'Ed25519'}, true, ['sign','verify']);  const pub = await crypto.subtle.exportKey('raw', kp.publicKey);  const prv = await crypto.subtle.exportKey('pkcs8', kp.privateKey);  return {    publicKeyB64u: b64u.enc(pub),    privateKeyB64u: b64u.enc(prv)  };}/* ===== Signing (pure) ===== */async function signEd25519(messageStr, privateKeyPkcs8B64u) {  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);  if (!messageStr) throw new Error('message missing.');  if (!privateKeyPkcs8B64u) throw new Error('Ed25519 private key missing.');  const pkcs8 = b64u.dec(privateKeyPkcs8B64u);  const key = await crypto.subtle.importKey('pkcs8', pkcs8, {name:'Ed25519'}, false, ['sign']);  const sig = await crypto.subtle.sign({name:'Ed25519'}, key, txt.enc(messageStr));  return b64u.enc(sig);}/* ===== Encryption via X25519 + HKDF + AES-GCM (pure) ===== */async function encryptX25519(publicKeyRawB64u, messageStr) {  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);  if (!publicKeyRawB64u) throw new Error('X25519 public key missing.');  if (!messageStr) throw new Error('message missing.');  // recipient public key  const pubRaw = b64u.dec(publicKeyRawB64u);  const recipientPub = await crypto.subtle.importKey('raw', pubRaw, {name:'X25519'}, false, []);  // ephemeral key pair  const eph = await crypto.subtle.generateKey({name:'X25519'}, true, ['deriveBits']);  const ephPubRaw = await crypto.subtle.exportKey('raw', eph.publicKey);  // derive shared secret  const shared = await crypto.subtle.deriveBits({name:'X25519', public: recipientPub}, eph.privateKey, 256);  // KDF  const salt = crypto.getRandomValues(new Uint8Array(16));  const ikm = await crypto.subtle.importKey('raw', shared, 'HKDF', false, ['deriveKey']);  const aesKey = await crypto.subtle.deriveKey(    { name:'HKDF', hash:'SHA-256', salt, info: txt.enc('X25519-AES-GCM') },    ikm,    { name:'AES-GCM', length:256 },    false,    ['encrypt']  );  // encrypt  const iv = crypto.getRandomValues(new Uint8Array(12));  const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, aesKey, txt.enc(messageStr));  // package: versioned, includes eph pub, salt, iv, ct  return jsonStringifyCompact({    v: 1,    kem: 'X25519-HKDF-SHA256',    aead: 'AES-GCM-256',    epk: b64u.enc(ephPubRaw),    salt: b64u.enc(salt.buffer),    iv: b64u.enc(iv.buffer),    ct: b64u.enc(ct)  });}/* ===== Verification (pure) ===== */async function verifyEd25519(messageStr, signatureB64u, publicKeyRawB64u) {  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);  if (!messageStr) throw new Error('message missing.');  if (!signatureB64u) throw new Error('signature missing.');  if (!publicKeyRawB64u) throw new Error('Ed25519 public key missing.');  const pubRaw = b64u.dec(publicKeyRawB64u);  const key = await crypto.subtle.importKey('raw', pubRaw, {name:'Ed25519'}, false, ['verify']);  const ok = await crypto.subtle.verify({name:'Ed25519'}, key, b64u.dec(signatureB64u), txt.enc(messageStr));  return !!ok;}/* ===== Decryption (pure) ===== */async function decryptX25519(privateKeyPkcs8B64u, payloadJson) {  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);  if (!privateKeyPkcs8B64u) throw new Error('X25519 private key missing.');  if (!payloadJson) throw new Error('encrypted payload missing.');  let payload;  try { payload = JSON.parse(payloadJson); }  catch { throw new Error('bad payload format.'); }  const { v, epk, salt, iv, ct, kem, aead } = payload;  if (v!==1 || kem!=='X25519-HKDF-SHA256' || aead!=='AES-GCM-256') throw new Error('unsupported payload params.');  const prv = await crypto.subtle.importKey('pkcs8', b64u.dec(privateKeyPkcs8B64u), {name:'X25519'}, false, ['deriveBits']);  const ephPub = await crypto.subtle.importKey('raw', b64u.dec(epk), {name:'X25519'}, false, []);  const shared = await crypto.subtle.deriveBits({name:'X25519', public: ephPub}, prv, 256);  const ikm = await crypto.subtle.importKey('raw', shared, 'HKDF', false, ['deriveKey']);  const aesKey = await crypto.subtle.deriveKey(    { name:'HKDF', hash:'SHA-256', salt: new Uint8Array(b64u.dec(salt)), info: txt.enc('X25519-AES-GCM') },    ikm,    { name:'AES-GCM', length:256 },    false,    ['decrypt']  );  const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv: new Uint8Array(b64u.dec(iv))}, aesKey, b64u.dec(ct));  return txt.dec(pt);}/* ===== Minimal DOM wire-up ===== */function warn(el, msg) { el.textContent = msg || ''; }function setVal(id, v) { document.getElementById(id).value = v; }document.getElementById('generateX25519').addEventListener('click', async () => {  const w = document.getElementById('warn-sec1'); warn(w,'');  try {    const k = await genX25519();    // Exported separately to avoid leakage. Public contains no private data.    setVal('privatekeyX25519', k.privateKeyB64u);    setVal('publickeyX25519',  k.publicKeyB64u);    warn(w,'ok');  } catch(e){ warn(w, e.message); }});document.getElementById('generateEd25519').addEventListener('click', async () => {  const w = document.getElementById('warn-sec1'); warn(w,'');  try {    const k = await genEd25519();    setVal('privatekeyEd25519', k.privateKeyB64u);    setVal('publickeyEd25519',  k.publicKeyB64u);    warn(w,'ok');  } catch(e){ warn(w, e.message); }});document.getElementById('sign').addEventListener('click', async () => {  const w = document.getElementById('warn-sign'); warn(w,'');  try {    const sig = await signEd25519(      document.getElementById('message').value,      document.getElementById('privatekeyEd25519').value.trim()    );    setVal('signature', sig);    warn(w, 'ok');  } catch(e){ warn(w, e.message); }});document.getElementById('encrypt').addEventListener('click', async () => {  const w = document.getElementById('warn-encrypt'); warn(w,'');  try {    const enc = await encryptX25519(      document.getElementById('publickeyX25519').value.trim(),      document.getElementById('message').value    );    setVal('encrypted', enc);    warn(w, 'ok');  } catch(e){ warn(w, e.message); }});document.getElementById('verify').addEventListener('click', async () => {  const w = document.getElementById('warn-verify'); warn(w,'');  const msg = document.getElementById('message').value;  const sig = document.getElementById('signature').value.trim();  const pub = document.getElementById('publickeyEd25519').value.trim();  try {    const ok = await verifyEd25519(msg, sig, pub);    document.getElementById('valid-message-signature').textContent = ok ? 'valid' : 'invalid';    setVal('verified', jsonStringifyCompact({message: msg, signature: sig}));    warn(w, 'ok');  } catch(e){ warn(w, e.message); }});document.getElementById('decrypt').addEventListener('click', async () => {  const w = document.getElementById('warn-decrypt'); warn(w,'');  try {    const pt = await decryptX25519(      document.getElementById('privatekeyX25519').value.trim(),      document.getElementById('encrypted').value.trim()    );    setVal('decrypted', pt);    warn(w, 'ok');  } catch(e){ warn(w, e.message); }});/* Copy buttons: every textarea has a sibling button#copy. Multiple same-IDs handled by querySelectorAll. */document.querySelectorAll('button#copy').forEach(btn=>{  btn.addEventListener('click', async () => {    const id = btn.getAttribute('data-for');    const ta = document.getElementById(id);    if (!ta) return;    try { await navigator.clipboard.writeText(ta.value); } catch {}  });});</script></body></html>